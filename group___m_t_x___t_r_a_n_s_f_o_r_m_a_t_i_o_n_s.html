<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr Scientific Library (zscilib): Transformation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr Scientific Library (zscilib)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Transformation<div class="ingroups"><a class="el" href="group___m_a_t_r_i_c_e_s.html">Matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Transformation functions for matrices (transpose, inverse, guassian elimination, etc.).  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0eb736476f31c46e346958708006829e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga0eb736476f31c46e346958708006829e">zsl_mtx_trans</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *ma, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mb)</td></tr>
<tr class="memdesc:ga0eb736476f31c46e346958708006829e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes the matrix 'ma' into matrix 'mb'. Note that output matrix 'mb' must have 'ma-&gt;sz_rows' columns, and 'ma-&gt;sz_cols' rows.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga0eb736476f31c46e346958708006829e">More...</a><br /></td></tr>
<tr class="separator:ga0eb736476f31c46e346958708006829e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga969fb6872a3d2d5bad81467f1c82c7b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga969fb6872a3d2d5bad81467f1c82c7b5">zsl_mtx_adjoint_3x3</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *ma)</td></tr>
<tr class="memdesc:ga969fb6872a3d2d5bad81467f1c82c7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the ajoint matrix, based on the input 3x3 matrix 'm'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga969fb6872a3d2d5bad81467f1c82c7b5">More...</a><br /></td></tr>
<tr class="separator:ga969fb6872a3d2d5bad81467f1c82c7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c15f90b7cba1a35fdf9d2a83ca2bccb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga5c15f90b7cba1a35fdf9d2a83ca2bccb">zsl_mtx_adjoint</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *ma)</td></tr>
<tr class="memdesc:ga5c15f90b7cba1a35fdf9d2a83ca2bccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the ajoint matrix, based on the input square matrix 'm'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga5c15f90b7cba1a35fdf9d2a83ca2bccb">More...</a><br /></td></tr>
<tr class="separator:ga5c15f90b7cba1a35fdf9d2a83ca2bccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8acd7f91d2c7a29aaaf69170a4dfc568"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga8acd7f91d2c7a29aaaf69170a4dfc568">zsl_mtx_vec_wedge</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__vec.html">zsl_vec</a> *v)</td></tr>
<tr class="memdesc:ga8acd7f91d2c7a29aaaf69170a4dfc568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the wedge product of n-1 vectors of size n, which are the rows of the matrix 'm'. This n-1 vectors must be linearly independent.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga8acd7f91d2c7a29aaaf69170a4dfc568">More...</a><br /></td></tr>
<tr class="separator:ga8acd7f91d2c7a29aaaf69170a4dfc568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef303884e2ba3a6a9aa44d17033f0501"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaef303884e2ba3a6a9aa44d17033f0501">zsl_mtx_reduce</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mr, size_t i, size_t j)</td></tr>
<tr class="memdesc:gaef303884e2ba3a6a9aa44d17033f0501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes row 'i' and column 'j' from square matrix 'm', assigning the remaining elements in the matrix to 'mr'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaef303884e2ba3a6a9aa44d17033f0501">More...</a><br /></td></tr>
<tr class="separator:gaef303884e2ba3a6a9aa44d17033f0501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1a41d666f1657eaa86d8a4b3dfb67c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaa1a41d666f1657eaa86d8a4b3dfb67c0">zsl_mtx_reduce_iter</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mred)</td></tr>
<tr class="memdesc:gaa1a41d666f1657eaa86d8a4b3dfb67c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the number of rows/columns in the input square matrix 'm' to match the shape of 'mred', where mred &lt; m. Rows/cols will be removed starting on the left and upper vectors.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaa1a41d666f1657eaa86d8a4b3dfb67c0">More...</a><br /></td></tr>
<tr class="separator:gaa1a41d666f1657eaa86d8a4b3dfb67c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3463aef4a3593cc9e20edc859a83bc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaa3463aef4a3593cc9e20edc859a83bc6">zsl_mtx_augm_diag</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *maug)</td></tr>
<tr class="memdesc:gaa3463aef4a3593cc9e20edc859a83bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Augments the input square matrix with additional rows and columns, based on the size 'diff' between m and maug (where maug &gt; m). New rows and columns are assigned values based on an identity matrix, meaning 1.0 on the new diagonal values and 0.0 above and below the diagonal.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaa3463aef4a3593cc9e20edc859a83bc6">More...</a><br /></td></tr>
<tr class="separator:gaa3463aef4a3593cc9e20edc859a83bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7531eca1242868f4476e97b6b1c836df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga7531eca1242868f4476e97b6b1c836df">zsl_mtx_deter_3x3</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, <a class="el" href="zsl_8h.html#a057fbb03c8054ee788abfe8231ad8c81">zsl_real_t</a> *d)</td></tr>
<tr class="memdesc:ga7531eca1242868f4476e97b6b1c836df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the determinant of the input 3x3 matrix 'm'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga7531eca1242868f4476e97b6b1c836df">More...</a><br /></td></tr>
<tr class="separator:ga7531eca1242868f4476e97b6b1c836df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a6f65ffda35bed1f042bb8d7603e572"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga5a6f65ffda35bed1f042bb8d7603e572">zsl_mtx_deter</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, <a class="el" href="zsl_8h.html#a057fbb03c8054ee788abfe8231ad8c81">zsl_real_t</a> *d)</td></tr>
<tr class="memdesc:ga5a6f65ffda35bed1f042bb8d7603e572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the determinant of the input square matrix 'm'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga5a6f65ffda35bed1f042bb8d7603e572">More...</a><br /></td></tr>
<tr class="separator:ga5a6f65ffda35bed1f042bb8d7603e572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a1ff09dc06d65d016b2153bb77baa14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga0a1ff09dc06d65d016b2153bb77baa14">zsl_mtx_gauss_elim</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mg, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mi, size_t i, size_t j)</td></tr>
<tr class="memdesc:ga0a1ff09dc06d65d016b2153bb77baa14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the element (i,j) in matrix 'm', this function performs gaussian elimination by adding row 'i' to the other rows until all of the elements in column 'j' are equal to 0.0, aside from the element at position (i, j). The result of this process will be assigned to matrix 'mg'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga0a1ff09dc06d65d016b2153bb77baa14">More...</a><br /></td></tr>
<tr class="separator:ga0a1ff09dc06d65d016b2153bb77baa14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4cc183aea8b54e3a7c9b15f7d855637"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaf4cc183aea8b54e3a7c9b15f7d855637">zsl_mtx_gauss_elim_d</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mi, size_t i, size_t j)</td></tr>
<tr class="memdesc:gaf4cc183aea8b54e3a7c9b15f7d855637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the element (i,j) in matrix 'm', this function performs gaussian elimination by adding row 'i' to the other rows until all of the elements in column 'j' are equal to 0.0, aside from the element at position (i, j). This function is destructive and will modify the contents of m.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaf4cc183aea8b54e3a7c9b15f7d855637">More...</a><br /></td></tr>
<tr class="separator:gaf4cc183aea8b54e3a7c9b15f7d855637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75b64b8d5fa54b8df6731c64a20109dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga75b64b8d5fa54b8df6731c64a20109dd">zsl_mtx_gauss_reduc</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mi, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mg)</td></tr>
<tr class="memdesc:ga75b64b8d5fa54b8df6731c64a20109dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given matrix 'm', puts the matrix into echelon form using Gauss-Jordan reduction.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga75b64b8d5fa54b8df6731c64a20109dd">More...</a><br /></td></tr>
<tr class="separator:ga75b64b8d5fa54b8df6731c64a20109dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga756944b115550c5798f4270b641cd1bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga756944b115550c5798f4270b641cd1bb">zsl_mtx_cols_norm</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mnorm)</td></tr>
<tr class="memdesc:ga756944b115550c5798f4270b641cd1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the values of every column vector in input matrix 'm' to have unitary values.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga756944b115550c5798f4270b641cd1bb">More...</a><br /></td></tr>
<tr class="separator:ga756944b115550c5798f4270b641cd1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33556c879cbd3afe108506041e21a761"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga33556c879cbd3afe108506041e21a761">zsl_mtx_gram_schmidt</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mort)</td></tr>
<tr class="memdesc:ga33556c879cbd3afe108506041e21a761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Gram-Schmidt algorithm on the set of column vectors in matrix 'm'. This algorithm calculates a set of orthogonal vectors in the same vectorial space as the original vectors.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga33556c879cbd3afe108506041e21a761">More...</a><br /></td></tr>
<tr class="separator:ga33556c879cbd3afe108506041e21a761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf5e94e0ebfd5599d84b4eba90430c54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gabf5e94e0ebfd5599d84b4eba90430c54">zsl_mtx_norm_elem</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mn, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mi, size_t i, size_t j)</td></tr>
<tr class="memdesc:gabf5e94e0ebfd5599d84b4eba90430c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalises elements in matrix m such that the element at position (i, j) is equal to 1.0.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gabf5e94e0ebfd5599d84b4eba90430c54">More...</a><br /></td></tr>
<tr class="separator:gabf5e94e0ebfd5599d84b4eba90430c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ead751c3d4ce5a5081836febd21b6d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga7ead751c3d4ce5a5081836febd21b6d5">zsl_mtx_norm_elem_d</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mi, size_t i, size_t j)</td></tr>
<tr class="memdesc:ga7ead751c3d4ce5a5081836febd21b6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalises elements in matrix m such that the element at position (i, j) is equal to 1.0. This function is destructive and will modify the contents of m.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga7ead751c3d4ce5a5081836febd21b6d5">More...</a><br /></td></tr>
<tr class="separator:ga7ead751c3d4ce5a5081836febd21b6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa96f965d0fb43be0fc08b957ac4ca85d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaa96f965d0fb43be0fc08b957ac4ca85d">zsl_mtx_inv_3x3</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mi)</td></tr>
<tr class="memdesc:gaa96f965d0fb43be0fc08b957ac4ca85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse of 3x3 matrix 'm'. If the determinant of 'm' is zero, an identity matrix will be returned via 'mi'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaa96f965d0fb43be0fc08b957ac4ca85d">More...</a><br /></td></tr>
<tr class="separator:gaa96f965d0fb43be0fc08b957ac4ca85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6268baeb64622466c50c6950f89a8392"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga6268baeb64622466c50c6950f89a8392">zsl_mtx_inv</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mi)</td></tr>
<tr class="memdesc:ga6268baeb64622466c50c6950f89a8392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse of square matrix 'm'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga6268baeb64622466c50c6950f89a8392">More...</a><br /></td></tr>
<tr class="separator:ga6268baeb64622466c50c6950f89a8392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9742df56d688a36fe9ede6796638fb5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga9742df56d688a36fe9ede6796638fb5c">zsl_mtx_cholesky</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *l)</td></tr>
<tr class="memdesc:ga9742df56d688a36fe9ede6796638fb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Cholesky decomposition of a symmetric square matrix using the Cholesky–Crout algorithm.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga9742df56d688a36fe9ede6796638fb5c">More...</a><br /></td></tr>
<tr class="separator:ga9742df56d688a36fe9ede6796638fb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f6237b030695a1e3c6603eecd47448c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga1f6237b030695a1e3c6603eecd47448c">zsl_mtx_balance</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mout)</td></tr>
<tr class="memdesc:ga1f6237b030695a1e3c6603eecd47448c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balances the square matrix 'm', a process in which the eigenvalues of the output matrix are the same as the eigenvalues of the input matrix.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga1f6237b030695a1e3c6603eecd47448c">More...</a><br /></td></tr>
<tr class="separator:ga1f6237b030695a1e3c6603eecd47448c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa8cbce5a3094d2292f1e4ec3402b470"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gafa8cbce5a3094d2292f1e4ec3402b470">zsl_mtx_householder</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *h, bool hessenberg)</td></tr>
<tr class="memdesc:gafa8cbce5a3094d2292f1e4ec3402b470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the householder reflection of 'm'. Used as part of QR decomposition. When 'hessenberg' is active, it calculates the householder reflection but without using the first line of 'm'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gafa8cbce5a3094d2292f1e4ec3402b470">More...</a><br /></td></tr>
<tr class="separator:gafa8cbce5a3094d2292f1e4ec3402b470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b76643a6acf826c442cfa24e5fe83d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaf9b76643a6acf826c442cfa24e5fe83d">zsl_mtx_qrd</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *q, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *r, bool hessenberg)</td></tr>
<tr class="memdesc:gaf9b76643a6acf826c442cfa24e5fe83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 'hessenberg' is set to false, this function performs the QR decomposition, which is a factorisation of matrix 'm' into an orthogonal matrix (q) and an upper triangular matrix (r). If 'hessenberg' is set to true, this function puts the matrix 'm' into hessenberg form. This function uses the householder reflections.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaf9b76643a6acf826c442cfa24e5fe83d">More...</a><br /></td></tr>
<tr class="separator:gaf9b76643a6acf826c442cfa24e5fe83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1156b53e640a1dbab183a18eac2db93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaa1156b53e640a1dbab183a18eac2db93">zsl_mtx_qrd_iter</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mout, size_t iter)</td></tr>
<tr class="memdesc:gaa1156b53e640a1dbab183a18eac2db93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes recursively the QR decompisition method to put the input square matrix into upper triangular form.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaa1156b53e640a1dbab183a18eac2db93">More...</a><br /></td></tr>
<tr class="separator:gaa1156b53e640a1dbab183a18eac2db93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0289da37e5c6f926a7513ac13fa2b158"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga0289da37e5c6f926a7513ac13fa2b158">zsl_mtx_eigenvalues</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__vec.html">zsl_vec</a> *v, size_t iter)</td></tr>
<tr class="memdesc:ga0289da37e5c6f926a7513ac13fa2b158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the eigenvalues for input matrix 'm' using QR decomposition recursively. The output vector will only contain real eigenvalues, even if the input matrix has complex eigenvalues.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga0289da37e5c6f926a7513ac13fa2b158">More...</a><br /></td></tr>
<tr class="separator:ga0289da37e5c6f926a7513ac13fa2b158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0176385192f0884c6ec58d81d8a0a78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaa0176385192f0884c6ec58d81d8a0a78">zsl_mtx_eigenvectors</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mev, size_t iter, bool orthonormal)</td></tr>
<tr class="memdesc:gaa0176385192f0884c6ec58d81d8a0a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcualtes the set of eigenvectors for input matrix 'm', using the specified number of iterations to find a balance between precision and processing effort. Optionally, the output eigenvectors can be orthonormalised.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaa0176385192f0884c6ec58d81d8a0a78">More...</a><br /></td></tr>
<tr class="separator:gaa0176385192f0884c6ec58d81d8a0a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga443cf9708594a814e8bc6a2fb5c60612"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga443cf9708594a814e8bc6a2fb5c60612">zsl_mtx_svd</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *u, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *e, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *v, size_t iter)</td></tr>
<tr class="memdesc:ga443cf9708594a814e8bc6a2fb5c60612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs singular value decomposition, converting input matrix 'm' into matrices 'u', 'e', and 'v'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga443cf9708594a814e8bc6a2fb5c60612">More...</a><br /></td></tr>
<tr class="separator:ga443cf9708594a814e8bc6a2fb5c60612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab54e0c3ffbd2b626284628688316293a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gab54e0c3ffbd2b626284628688316293a">zsl_mtx_pinv</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *pinv, size_t iter)</td></tr>
<tr class="memdesc:gab54e0c3ffbd2b626284628688316293a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the pseudo-inverse (aka pinv or Moore-Penrose inverse) on input matrix 'm'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gab54e0c3ffbd2b626284628688316293a">More...</a><br /></td></tr>
<tr class="separator:gab54e0c3ffbd2b626284628688316293a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Transformation functions for matrices (transpose, inverse, guassian elimination, etc.). </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5c15f90b7cba1a35fdf9d2a83ca2bccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c15f90b7cba1a35fdf9d2a83ca2bccb">&#9670;&nbsp;</a></span>zsl_mtx_adjoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_adjoint </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>ma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the ajoint matrix, based on the input square matrix 'm'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The input square matrix to use. </td></tr>
    <tr><td class="paramname">ma</td><td>The output square matrix the adjoint values will be assigned to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, or -EINVAL if this isn't a square matrix. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l00572">572</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

</div>
</div>
<a id="ga969fb6872a3d2d5bad81467f1c82c7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga969fb6872a3d2d5bad81467f1c82c7b5">&#9670;&nbsp;</a></span>zsl_mtx_adjoint_3x3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_adjoint_3x3 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>ma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the ajoint matrix, based on the input 3x3 matrix 'm'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The input 3x3 square matrix to use. </td></tr>
    <tr><td class="paramname">ma</td><td>The output 3x3 square matrix the adjoint values will be assigned to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, or -EINVAL if this isn't a 3x3 square matrix. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l00534">534</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l00572">zsl_mtx_adjoint()</a>, and <a class="el" href="matrices_8c_source.html#l01009">zsl_mtx_inv_3x3()</a>.</p>

</div>
</div>
<a id="gaa3463aef4a3593cc9e20edc859a83bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3463aef4a3593cc9e20edc859a83bc6">&#9670;&nbsp;</a></span>zsl_mtx_augm_diag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_augm_diag </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>maug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Augments the input square matrix with additional rows and columns, based on the size 'diff' between m and maug (where maug &gt; m). New rows and columns are assigned values based on an identity matrix, meaning 1.0 on the new diagonal values and 0.0 above and below the diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to the input square matrix. </td></tr>
    <tr><td class="paramname">maug</td><td>Pointer the the augmented output square matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, otherwise an appropriate error code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l00696">696</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l01254">zsl_mtx_householder()</a>, and <a class="el" href="matrices_8c_source.html#l01318">zsl_mtx_qrd()</a>.</p>

</div>
</div>
<a id="ga1f6237b030695a1e3c6603eecd47448c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f6237b030695a1e3c6603eecd47448c">&#9670;&nbsp;</a></span>zsl_mtx_balance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_balance </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Balances the square matrix 'm', a process in which the eigenvalues of the output matrix are the same as the eigenvalues of the input matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The input square matrix to use. </td></tr>
    <tr><td class="paramname">mout</td><td>The output balanced matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, otherwise an appropriate error code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l01173">1173</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l01398">zsl_mtx_eigenvalues()</a>.</p>

</div>
</div>
<a id="ga9742df56d688a36fe9ede6796638fb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9742df56d688a36fe9ede6796638fb5c">&#9670;&nbsp;</a></span>zsl_mtx_cholesky()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_cholesky </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the Cholesky decomposition of a symmetric square matrix using the Cholesky–Crout algorithm. </p>
<p>Computing the Cholesky decomposition of a symmetric square matrix M consists in finding a matrix L such that M = L * Lt (L multiplied by its transpose).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The input symmetric square matrix to use. </td></tr>
    <tr><td class="paramname">l</td><td>The output lower triangular matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, or -EINVAL if 'm' isn't a symmetric square matrix. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l01116">1116</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

</div>
</div>
<a id="ga756944b115550c5798f4270b641cd1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga756944b115550c5798f4270b641cd1bb">&#9670;&nbsp;</a></span>zsl_mtx_cols_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_cols_norm </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mnorm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the values of every column vector in input matrix 'm' to have unitary values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to the input matrix. </td></tr>
    <tr><td class="paramname">mnorm</td><td>Pointer to the output matrix where the columns are unitary vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, otherwise an appropriate error code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l00951">951</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l01504">zsl_mtx_eigenvectors()</a>.</p>

</div>
</div>
<a id="ga5a6f65ffda35bed1f042bb8d7603e572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a6f65ffda35bed1f042bb8d7603e572">&#9670;&nbsp;</a></span>zsl_mtx_deter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_deter </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zsl_8h.html#a057fbb03c8054ee788abfe8231ad8c81">zsl_real_t</a> *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the determinant of the input square matrix 'm'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The input square matrix to use. </td></tr>
    <tr><td class="paramname">d</td><td>The determinant of square matrix m.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, or -EINVAL if this isn't a square matrix. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l00744">744</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l00572">zsl_mtx_adjoint()</a>, <a class="el" href="matrices_8c_source.html#l01064">zsl_mtx_inv()</a>, <a class="el" href="matrices_8c_source.html#l00607">zsl_mtx_vec_wedge()</a>, <a class="el" href="statistics_8c_source.html#l00466">zsl_sta_mult_linear_reg()</a>, and <a class="el" href="statistics_8c_source.html#l00535">zsl_sta_weighted_mult_linear_reg()</a>.</p>

</div>
</div>
<a id="ga7531eca1242868f4476e97b6b1c836df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7531eca1242868f4476e97b6b1c836df">&#9670;&nbsp;</a></span>zsl_mtx_deter_3x3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_deter_3x3 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="zsl_8h.html#a057fbb03c8054ee788abfe8231ad8c81">zsl_real_t</a> *&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the determinant of the input 3x3 matrix 'm'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The input 3x3 square matrix to use. </td></tr>
    <tr><td class="paramname">d</td><td>The determinant of 3x3 square matrix m.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or -EINVAL if this isn't a 3x3 square matrix. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l00714">714</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l00744">zsl_mtx_deter()</a>, and <a class="el" href="matrices_8c_source.html#l01009">zsl_mtx_inv_3x3()</a>.</p>

</div>
</div>
<a id="ga0289da37e5c6f926a7513ac13fa2b158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0289da37e5c6f926a7513ac13fa2b158">&#9670;&nbsp;</a></span>zsl_mtx_eigenvalues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_eigenvalues </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__vec.html">zsl_vec</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the eigenvalues for input matrix 'm' using QR decomposition recursively. The output vector will only contain real eigenvalues, even if the input matrix has complex eigenvalues. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The input square matrix to use. </td></tr>
    <tr><td class="paramname">v</td><td>The placeholder for the output vector where the real eigenvalues should be stored. </td></tr>
    <tr><td class="paramname">iter</td><td>The number of times that 'zsl_mtx_qrd' should be called during the QR decomposition phase.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: Large values required more iterations to get precise results, and some trial and error may be required to find the right balance of iterations versus processing time.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, otherwise an appropriate error code. If -ECOMPLEXVAL is returned, it means that complex numbers were detected in the output eigenvalues. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l01398">1398</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l01504">zsl_mtx_eigenvectors()</a>, and <a class="el" href="matrices_8c_source.html#l01652">zsl_mtx_svd()</a>.</p>

</div>
</div>
<a id="gaa0176385192f0884c6ec58d81d8a0a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0176385192f0884c6ec58d81d8a0a78">&#9670;&nbsp;</a></span>zsl_mtx_eigenvectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_eigenvectors </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orthonormal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calcualtes the set of eigenvectors for input matrix 'm', using the specified number of iterations to find a balance between precision and processing effort. Optionally, the output eigenvectors can be orthonormalised. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The input square matrix to use. </td></tr>
    <tr><td class="paramname">mev</td><td>The placeholder for the output square matrix where the eigenvectors should be stored as column vectors. </td></tr>
    <tr><td class="paramname">iter</td><td>The number of times that 'zsl_mtx_qrd' should be called. during the QR decomposition phase. </td></tr>
    <tr><td class="paramname">orthonormal</td><td>If set to true, the output matrix 'mev' will be orthonormalised.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: Large values required more iterations to get precise results, and some trial and error may be required to find the right balance of iterations versus processing time.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, otherwise an appropriate error code. If the number of calcualted eigenvectors is less than the columns in 'm', EEIGENSIZE will be returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l01504">1504</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l01652">zsl_mtx_svd()</a>.</p>

</div>
</div>
<a id="ga0a1ff09dc06d65d016b2153bb77baa14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a1ff09dc06d65d016b2153bb77baa14">&#9670;&nbsp;</a></span>zsl_mtx_gauss_elim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_gauss_elim </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the element (i,j) in matrix 'm', this function performs gaussian elimination by adding row 'i' to the other rows until all of the elements in column 'j' are equal to 0.0, aside from the element at position (i, j). The result of this process will be assigned to matrix 'mg'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to input <a class="el" href="structzsl__mtx.html" title="Represents a m x n matrix, with data stored in row-major order.">zsl_mtx</a> to use. </td></tr>
    <tr><td class="paramname">mg</td><td>Pointer to gaussian form output matrix. </td></tr>
    <tr><td class="paramname">mi</td><td>Pointer to the identity output matrix. </td></tr>
    <tr><td class="paramname">i</td><td>The row number of the element to use (0-based). </td></tr>
    <tr><td class="paramname">j</td><td>The column number of the element to use (0-based).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, and non-zero error code on failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l00809">809</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l00861">zsl_mtx_gauss_elim_d()</a>.</p>

</div>
</div>
<a id="gaf4cc183aea8b54e3a7c9b15f7d855637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4cc183aea8b54e3a7c9b15f7d855637">&#9670;&nbsp;</a></span>zsl_mtx_gauss_elim_d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_gauss_elim_d </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the element (i,j) in matrix 'm', this function performs gaussian elimination by adding row 'i' to the other rows until all of the elements in column 'j' are equal to 0.0, aside from the element at position (i, j). This function is destructive and will modify the contents of m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to <a class="el" href="structzsl__mtx.html" title="Represents a m x n matrix, with data stored in row-major order.">zsl_mtx</a> to use. </td></tr>
    <tr><td class="paramname">mi</td><td>Pointer to the identity output matrix. </td></tr>
    <tr><td class="paramname">i</td><td>The row number of the element to use (0-based). </td></tr>
    <tr><td class="paramname">j</td><td>The column number of the element to use (0-based).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, and non-zero error code on failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l00861">861</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l00867">zsl_mtx_gauss_reduc()</a>.</p>

</div>
</div>
<a id="ga75b64b8d5fa54b8df6731c64a20109dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75b64b8d5fa54b8df6731c64a20109dd">&#9670;&nbsp;</a></span>zsl_mtx_gauss_reduc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_gauss_reduc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given matrix 'm', puts the matrix into echelon form using Gauss-Jordan reduction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to the input square matrix to use. </td></tr>
    <tr><td class="paramname">mi</td><td>Pointer to the identity output matrix. </td></tr>
    <tr><td class="paramname">mg</td><td>Pointer to the output square matrix in echelon form.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, and non-zero error code on failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l00867">867</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l01504">zsl_mtx_eigenvectors()</a>, and <a class="el" href="matrices_8c_source.html#l01064">zsl_mtx_inv()</a>.</p>

</div>
</div>
<a id="ga33556c879cbd3afe108506041e21a761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33556c879cbd3afe108506041e21a761">&#9670;&nbsp;</a></span>zsl_mtx_gram_schmidt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_gram_schmidt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the Gram-Schmidt algorithm on the set of column vectors in matrix 'm'. This algorithm calculates a set of orthogonal vectors in the same vectorial space as the original vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to the input matrix containing the vector data. </td></tr>
    <tr><td class="paramname">mort</td><td>Pointer to the output matrix containing the orthogonal vector data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, otherwise an appropriate error code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l00922">922</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l01504">zsl_mtx_eigenvectors()</a>.</p>

</div>
</div>
<a id="gafa8cbce5a3094d2292f1e4ec3402b470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa8cbce5a3094d2292f1e4ec3402b470">&#9670;&nbsp;</a></span>zsl_mtx_householder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_householder </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hessenberg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the householder reflection of 'm'. Used as part of QR decomposition. When 'hessenberg' is active, it calculates the householder reflection but without using the first line of 'm'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to the input matrix to use. </td></tr>
    <tr><td class="paramname">hessenberg</td><td>If set to true, the first line in 'm' is ignored. </td></tr>
    <tr><td class="paramname">h</td><td>Pointer to the output square matrix where the values of the householder reflection should be assigned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, otherwise an appropriate error code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l01254">1254</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l01318">zsl_mtx_qrd()</a>.</p>

</div>
</div>
<a id="ga6268baeb64622466c50c6950f89a8392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6268baeb64622466c50c6950f89a8392">&#9670;&nbsp;</a></span>zsl_mtx_inv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_inv </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the inverse of square matrix 'm'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The input square matrix to use. </td></tr>
    <tr><td class="paramname">mi</td><td>The output inverse square matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, or -EINVAL if this isn't a square matrix. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l01064">1064</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l00607">zsl_mtx_vec_wedge()</a>, <a class="el" href="statistics_8c_source.html#l00466">zsl_sta_mult_linear_reg()</a>, <a class="el" href="statistics_8c_source.html#l00618">zsl_sta_quad_fit()</a>, and <a class="el" href="statistics_8c_source.html#l00535">zsl_sta_weighted_mult_linear_reg()</a>.</p>

</div>
</div>
<a id="gaa96f965d0fb43be0fc08b957ac4ca85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa96f965d0fb43be0fc08b957ac4ca85d">&#9670;&nbsp;</a></span>zsl_mtx_inv_3x3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_inv_3x3 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the inverse of 3x3 matrix 'm'. If the determinant of 'm' is zero, an identity matrix will be returned via 'mi'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The input 3x3 matrix to use. </td></tr>
    <tr><td class="paramname">mi</td><td>The output inverse 3x3 matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, or -EINVAL if this isn't a 3x3 matrix. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l01009">1009</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l01064">zsl_mtx_inv()</a>.</p>

</div>
</div>
<a id="gabf5e94e0ebfd5599d84b4eba90430c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf5e94e0ebfd5599d84b4eba90430c54">&#9670;&nbsp;</a></span>zsl_mtx_norm_elem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_norm_elem </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalises elements in matrix m such that the element at position (i, j) is equal to 1.0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to input <a class="el" href="structzsl__mtx.html" title="Represents a m x n matrix, with data stored in row-major order.">zsl_mtx</a> to use. </td></tr>
    <tr><td class="paramname">mn</td><td>Pointer to normalised output <a class="el" href="structzsl__mtx.html" title="Represents a m x n matrix, with data stored in row-major order.">zsl_mtx</a>. </td></tr>
    <tr><td class="paramname">mi</td><td>Pointer to the output identity <a class="el" href="structzsl__mtx.html" title="Represents a m x n matrix, with data stored in row-major order.">zsl_mtx</a>. </td></tr>
    <tr><td class="paramname">i</td><td>The row number of the element to use (0-based). </td></tr>
    <tr><td class="paramname">j</td><td>The column number of the element to use (0-based).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, and non-zero error code on failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l00965">965</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l01003">zsl_mtx_norm_elem_d()</a>.</p>

</div>
</div>
<a id="ga7ead751c3d4ce5a5081836febd21b6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ead751c3d4ce5a5081836febd21b6d5">&#9670;&nbsp;</a></span>zsl_mtx_norm_elem_d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_norm_elem_d </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalises elements in matrix m such that the element at position (i, j) is equal to 1.0. This function is destructive and will modify the contents of m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to <a class="el" href="structzsl__mtx.html" title="Represents a m x n matrix, with data stored in row-major order.">zsl_mtx</a> to use. </td></tr>
    <tr><td class="paramname">mi</td><td>Pointer to the output identity <a class="el" href="structzsl__mtx.html" title="Represents a m x n matrix, with data stored in row-major order.">zsl_mtx</a>. </td></tr>
    <tr><td class="paramname">i</td><td>The row number of the element to use (0-based). </td></tr>
    <tr><td class="paramname">j</td><td>The column number of the element to use (0-based).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, and non-zero error code on failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l01003">1003</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l00867">zsl_mtx_gauss_reduc()</a>.</p>

</div>
</div>
<a id="gab54e0c3ffbd2b626284628688316293a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab54e0c3ffbd2b626284628688316293a">&#9670;&nbsp;</a></span>zsl_mtx_pinv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_pinv </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>pinv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the pseudo-inverse (aka pinv or Moore-Penrose inverse) on input matrix 'm'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The input mxn matrix to use. </td></tr>
    <tr><td class="paramname">pinv</td><td>The placeholder for the output pseudo inverse nxm matrix. </td></tr>
    <tr><td class="paramname">iter</td><td>The number of times that 'zsl_mtx_qrd' should be called. during the QR decomposition phase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, otherwise an appropriate error code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l01734">1734</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

</div>
</div>
<a id="gaf9b76643a6acf826c442cfa24e5fe83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9b76643a6acf826c442cfa24e5fe83d">&#9670;&nbsp;</a></span>zsl_mtx_qrd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_qrd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hessenberg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If 'hessenberg' is set to false, this function performs the QR decomposition, which is a factorisation of matrix 'm' into an orthogonal matrix (q) and an upper triangular matrix (r). If 'hessenberg' is set to true, this function puts the matrix 'm' into hessenberg form. This function uses the householder reflections. </p>
<p>One of the uses of this function is to make use of the householder method to perform the QR decomposition, which introduces the zeros below the diagonal of matrix 'r'. Other algorithms exist, such as the Gram-Schmidt process, but they tend to be less stable than the householder method for a similar computational cost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to the input square matrix. </td></tr>
    <tr><td class="paramname">q</td><td>Pointer to the output orthoogonal square matrix. </td></tr>
    <tr><td class="paramname">r</td><td>Pointer to the output upper triangular square matrix or hessenberg matrix if set to true. </td></tr>
    <tr><td class="paramname">hessenberg</td><td>Sets the matrix to hessenberg format if 'true'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, otherwise an appropriate error code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l01318">1318</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l01398">zsl_mtx_eigenvalues()</a>, and <a class="el" href="matrices_8c_source.html#l01369">zsl_mtx_qrd_iter()</a>.</p>

</div>
</div>
<a id="gaa1156b53e640a1dbab183a18eac2db93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1156b53e640a1dbab183a18eac2db93">&#9670;&nbsp;</a></span>zsl_mtx_qrd_iter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_qrd_iter </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes recursively the QR decompisition method to put the input square matrix into upper triangular form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The input square matrix to use when performing the QR decomposition. </td></tr>
    <tr><td class="paramname">mout</td><td>The output upper triangular square matrix where the results should be stored. </td></tr>
    <tr><td class="paramname">iter</td><td>The number of times that 'zsl_mtx_qrd' should be called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, otherwise an appropriate error code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l01369">1369</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l01398">zsl_mtx_eigenvalues()</a>.</p>

</div>
</div>
<a id="gaef303884e2ba3a6a9aa44d17033f0501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef303884e2ba3a6a9aa44d17033f0501">&#9670;&nbsp;</a></span>zsl_mtx_reduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_reduce </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes row 'i' and column 'j' from square matrix 'm', assigning the remaining elements in the matrix to 'mr'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The input nxn square matrix to use. </td></tr>
    <tr><td class="paramname">mr</td><td>The output (n-1)x(n-1) square matrix. </td></tr>
    <tr><td class="paramname">i</td><td>The row number to remove (0-based). </td></tr>
    <tr><td class="paramname">j</td><td>The column number to remove (0-based).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, or -EINVAL if this isn't a square matrix. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l00645">645</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l00572">zsl_mtx_adjoint()</a>, <a class="el" href="matrices_8c_source.html#l00744">zsl_mtx_deter()</a>, and <a class="el" href="matrices_8c_source.html#l00680">zsl_mtx_reduce_iter()</a>.</p>

</div>
</div>
<a id="gaa1a41d666f1657eaa86d8a4b3dfb67c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1a41d666f1657eaa86d8a4b3dfb67c0">&#9670;&nbsp;</a></span>zsl_mtx_reduce_iter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_reduce_iter </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces the number of rows/columns in the input square matrix 'm' to match the shape of 'mred', where mred &lt; m. Rows/cols will be removed starting on the left and upper vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to the input square matrix. </td></tr>
    <tr><td class="paramname">mred</td><td>Pointer the the reduced output square matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, otherwise an appropriate error code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l00680">680</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l01318">zsl_mtx_qrd()</a>.</p>

</div>
</div>
<a id="ga443cf9708594a814e8bc6a2fb5c60612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga443cf9708594a814e8bc6a2fb5c60612">&#9670;&nbsp;</a></span>zsl_mtx_svd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_svd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs singular value decomposition, converting input matrix 'm' into matrices 'u', 'e', and 'v'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The input mxn matrix to use. </td></tr>
    <tr><td class="paramname">u</td><td>The placeholder for the output mxm matrix u. </td></tr>
    <tr><td class="paramname">e</td><td>The placeholder for the output mxn matrix sigma. </td></tr>
    <tr><td class="paramname">v</td><td>The placeholder for the output nxn matrix v. </td></tr>
    <tr><td class="paramname">iter</td><td>The number of times that 'zsl_mtx_qrd' should be called. during the QR decomposition phase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, otherwise an appropriate error code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l01652">1652</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l01734">zsl_mtx_pinv()</a>.</p>

</div>
</div>
<a id="ga0eb736476f31c46e346958708006829e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eb736476f31c46e346958708006829e">&#9670;&nbsp;</a></span>zsl_mtx_trans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_trans </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>ma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transposes the matrix 'ma' into matrix 'mb'. Note that output matrix 'mb' must have 'ma-&gt;sz_rows' columns, and 'ma-&gt;sz_cols' rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ma</td><td>Pointer to the input matrix to transpose. </td></tr>
    <tr><td class="paramname">mb</td><td>Pointer to the output zsl_mtz.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, or -EINVAL if ma and mb are not compatibly shaped. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l00514">514</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l01254">zsl_mtx_householder()</a>, <a class="el" href="matrices_8c_source.html#l01734">zsl_mtx_pinv()</a>, <a class="el" href="matrices_8c_source.html#l01318">zsl_mtx_qrd()</a>, <a class="el" href="matrices_8c_source.html#l01652">zsl_mtx_svd()</a>, <a class="el" href="statistics_8c_source.html#l00466">zsl_sta_mult_linear_reg()</a>, <a class="el" href="statistics_8c_source.html#l00618">zsl_sta_quad_fit()</a>, and <a class="el" href="statistics_8c_source.html#l00535">zsl_sta_weighted_mult_linear_reg()</a>.</p>

</div>
</div>
<a id="ga8acd7f91d2c7a29aaaf69170a4dfc568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8acd7f91d2c7a29aaaf69170a4dfc568">&#9670;&nbsp;</a></span>zsl_mtx_vec_wedge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_vec_wedge </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__vec.html">zsl_vec</a> *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the wedge product of n-1 vectors of size n, which are the rows of the matrix 'm'. This n-1 vectors must be linearly independent. </p>
<p>The wedge product is an extension of the cross product for dimension greater than 3. Given a set of n-1 vectors of size n, the wedge product calculates a n-dimensional vector that is perpendicular to all the others.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The input (n-1) x n matrix, with n &gt; 3, whose rows are the linearly independent vectors to use in the wedge product. </td></tr>
    <tr><td class="paramname">v</td><td>The output vector of dimension n, perpendicular to all the input vectors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if everything executed correctly, or -EINVAL if n &gt; 3, or if the input matrix isn't of the form (n-1) x n. </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l00607">607</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
