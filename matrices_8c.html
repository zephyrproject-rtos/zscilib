<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zephyr Scientific Library (zscilib): src/matrices.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zephyr Scientific Library (zscilib)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">matrices.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;<a class="el" href="zsl_8h_source.html">zsl/zsl.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="matrices_8h_source.html">zsl/matrices.h</a>&gt;</code><br />
</div>
<p><a href="matrices_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae1119b93c922ed4f8341dc944c2dd568"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___i_n_i_t.html#gae1119b93c922ed4f8341dc944c2dd568">zsl_mtx_entry_fn_empty</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, size_t i, size_t j)</td></tr>
<tr class="memdesc:gae1119b93c922ed4f8341dc944c2dd568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a zero-value to all entries in the matrix.  <a href="group___m_t_x___i_n_i_t.html#gae1119b93c922ed4f8341dc944c2dd568">More...</a><br /></td></tr>
<tr class="separator:gae1119b93c922ed4f8341dc944c2dd568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65980b0abcc89a34c117fe2787a2bb85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___i_n_i_t.html#ga65980b0abcc89a34c117fe2787a2bb85">zsl_mtx_entry_fn_identity</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, size_t i, size_t j)</td></tr>
<tr class="memdesc:ga65980b0abcc89a34c117fe2787a2bb85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value to '1.0' if the entry is on the diagonal (row=col), otherwise '0.0'.  <a href="group___m_t_x___i_n_i_t.html#ga65980b0abcc89a34c117fe2787a2bb85">More...</a><br /></td></tr>
<tr class="separator:ga65980b0abcc89a34c117fe2787a2bb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68dec4d8bf079c8e4ffca9974ca8fb1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___i_n_i_t.html#ga68dec4d8bf079c8e4ffca9974ca8fb1e">zsl_mtx_entry_fn_random</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, size_t i, size_t j)</td></tr>
<tr class="memdesc:ga68dec4d8bf079c8e4ffca9974ca8fb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value to a random number between -1.0 and 1.0.  <a href="group___m_t_x___i_n_i_t.html#ga68dec4d8bf079c8e4ffca9974ca8fb1e">More...</a><br /></td></tr>
<tr class="separator:ga68dec4d8bf079c8e4ffca9974ca8fb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae54af5cabf717e4707d8d3489e73e24f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___i_n_i_t.html#gae54af5cabf717e4707d8d3489e73e24f">zsl_mtx_init</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, <a class="el" href="group___m_t_x___i_n_i_t.html#ga29e37bfec615602b847701605d1ddddf">zsl_mtx_init_entry_fn_t</a> entry_fn)</td></tr>
<tr class="memdesc:gae54af5cabf717e4707d8d3489e73e24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises matrix 'm' using the specified entry function to assign values.  <a href="group___m_t_x___i_n_i_t.html#gae54af5cabf717e4707d8d3489e73e24f">More...</a><br /></td></tr>
<tr class="separator:gae54af5cabf717e4707d8d3489e73e24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5491cbdd072855161ffb7746e4dda28c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___i_n_i_t.html#ga5491cbdd072855161ffb7746e4dda28c">zsl_mtx_from_arr</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, <a class="el" href="zsl_8h.html#a057fbb03c8054ee788abfe8231ad8c81">zsl_real_t</a> *a)</td></tr>
<tr class="memdesc:ga5491cbdd072855161ffb7746e4dda28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an array of values into a matrix.  <a href="group___m_t_x___i_n_i_t.html#ga5491cbdd072855161ffb7746e4dda28c">More...</a><br /></td></tr>
<tr class="separator:ga5491cbdd072855161ffb7746e4dda28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89ec2ac8064e43a80bcf550b7b300120"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___i_n_i_t.html#ga89ec2ac8064e43a80bcf550b7b300120">zsl_mtx_copy</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mdest, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *msrc)</td></tr>
<tr class="memdesc:ga89ec2ac8064e43a80bcf550b7b300120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the contents of matrix 'msrc' into matrix 'mdest'.  <a href="group___m_t_x___i_n_i_t.html#ga89ec2ac8064e43a80bcf550b7b300120">More...</a><br /></td></tr>
<tr class="separator:ga89ec2ac8064e43a80bcf550b7b300120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d011437cf2d70ae3b2de4de1e1e9bc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___d_a_t_a_c_c_e_s_s.html#ga9d011437cf2d70ae3b2de4de1e1e9bc3">zsl_mtx_get</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, size_t i, size_t j, <a class="el" href="zsl_8h.html#a057fbb03c8054ee788abfe8231ad8c81">zsl_real_t</a> *x)</td></tr>
<tr class="memdesc:ga9d011437cf2d70ae3b2de4de1e1e9bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a single value from the specified row (i) and column (j).  <a href="group___m_t_x___d_a_t_a_c_c_e_s_s.html#ga9d011437cf2d70ae3b2de4de1e1e9bc3">More...</a><br /></td></tr>
<tr class="separator:ga9d011437cf2d70ae3b2de4de1e1e9bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f193e06339c8318745eb4d22984eea3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___d_a_t_a_c_c_e_s_s.html#ga4f193e06339c8318745eb4d22984eea3">zsl_mtx_set</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, size_t i, size_t j, <a class="el" href="zsl_8h.html#a057fbb03c8054ee788abfe8231ad8c81">zsl_real_t</a> x)</td></tr>
<tr class="memdesc:ga4f193e06339c8318745eb4d22984eea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a single value at the specified row (i) and column (j).  <a href="group___m_t_x___d_a_t_a_c_c_e_s_s.html#ga4f193e06339c8318745eb4d22984eea3">More...</a><br /></td></tr>
<tr class="separator:ga4f193e06339c8318745eb4d22984eea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b84148a40c3c76d44314cf5a53265a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___d_a_t_a_c_c_e_s_s.html#ga2b84148a40c3c76d44314cf5a53265a6">zsl_mtx_get_row</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, size_t i, <a class="el" href="zsl_8h.html#a057fbb03c8054ee788abfe8231ad8c81">zsl_real_t</a> *v)</td></tr>
<tr class="memdesc:ga2b84148a40c3c76d44314cf5a53265a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the contents of row 'i' from matrix 'm', assigning the array of data to 'v'.  <a href="group___m_t_x___d_a_t_a_c_c_e_s_s.html#ga2b84148a40c3c76d44314cf5a53265a6">More...</a><br /></td></tr>
<tr class="separator:ga2b84148a40c3c76d44314cf5a53265a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52dc1321089dfb2db98a1a62a44bb7bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___d_a_t_a_c_c_e_s_s.html#ga52dc1321089dfb2db98a1a62a44bb7bb">zsl_mtx_set_row</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, size_t i, <a class="el" href="zsl_8h.html#a057fbb03c8054ee788abfe8231ad8c81">zsl_real_t</a> *v)</td></tr>
<tr class="memdesc:ga52dc1321089dfb2db98a1a62a44bb7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the contents of row 'i' in matrix 'm', assigning the values found in array 'v'.  <a href="group___m_t_x___d_a_t_a_c_c_e_s_s.html#ga52dc1321089dfb2db98a1a62a44bb7bb">More...</a><br /></td></tr>
<tr class="separator:ga52dc1321089dfb2db98a1a62a44bb7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga317b7ae2837afad93c1eb9e880d09e94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___d_a_t_a_c_c_e_s_s.html#ga317b7ae2837afad93c1eb9e880d09e94">zsl_mtx_get_col</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, size_t j, <a class="el" href="zsl_8h.html#a057fbb03c8054ee788abfe8231ad8c81">zsl_real_t</a> *v)</td></tr>
<tr class="memdesc:ga317b7ae2837afad93c1eb9e880d09e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the contents of column 'j' from matrix 'm', assigning the array of data to 'v'.  <a href="group___m_t_x___d_a_t_a_c_c_e_s_s.html#ga317b7ae2837afad93c1eb9e880d09e94">More...</a><br /></td></tr>
<tr class="separator:ga317b7ae2837afad93c1eb9e880d09e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22c99f278be25749c2bda0e0224d8f94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___d_a_t_a_c_c_e_s_s.html#ga22c99f278be25749c2bda0e0224d8f94">zsl_mtx_set_col</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, size_t j, <a class="el" href="zsl_8h.html#a057fbb03c8054ee788abfe8231ad8c81">zsl_real_t</a> *v)</td></tr>
<tr class="memdesc:ga22c99f278be25749c2bda0e0224d8f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the contents of column 'j' in matrix 'm', assigning the values found in array 'v'.  <a href="group___m_t_x___d_a_t_a_c_c_e_s_s.html#ga22c99f278be25749c2bda0e0224d8f94">More...</a><br /></td></tr>
<tr class="separator:ga22c99f278be25749c2bda0e0224d8f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3932e4991cd3ae7fc4b10a584104f757"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___o_p_e_r_a_n_d_s.html#ga3932e4991cd3ae7fc4b10a584104f757">zsl_mtx_unary_op</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, <a class="el" href="group___m_t_x___o_p_e_r_a_n_d_s.html#gaccb2b4c2d1d1a282bb5819bbf21fecb8">zsl_mtx_unary_op_t</a> op)</td></tr>
<tr class="memdesc:ga3932e4991cd3ae7fc4b10a584104f757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a unary operand on every coefficient in matrix 'm'.  <a href="group___m_t_x___o_p_e_r_a_n_d_s.html#ga3932e4991cd3ae7fc4b10a584104f757">More...</a><br /></td></tr>
<tr class="separator:ga3932e4991cd3ae7fc4b10a584104f757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd80909db4e363cf6dbf950811414f6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrices_8c.html#acd80909db4e363cf6dbf950811414f6a">zsl_mtx_unary_func</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, <a class="el" href="group___m_t_x___i_n_i_t.html#ga93ed6864f0c3adafcd4327cd88d96c0a">zsl_mtx_unary_fn_t</a> fn)</td></tr>
<tr class="memdesc:acd80909db4e363cf6dbf950811414f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a unary function on every coefficient in matrix 'm', using the specified 'zsl_mtx_apply_unary_fn_t' instance.  <a href="matrices_8c.html#acd80909db4e363cf6dbf950811414f6a">More...</a><br /></td></tr>
<tr class="separator:acd80909db4e363cf6dbf950811414f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56496e3a46a6b598c50a5e086d07a1af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrices_8c.html#a56496e3a46a6b598c50a5e086d07a1af">zsl_mtx_binary_op</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *ma, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mb, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mc, <a class="el" href="group___m_t_x___o_p_e_r_a_n_d_s.html#gac0cbe53e633a7f5536ce38079acc0ec1">zsl_mtx_binary_op_t</a> op)</td></tr>
<tr class="memdesc:a56496e3a46a6b598c50a5e086d07a1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a component-wise binary operation on every coefficient in symmetrical matrices 'ma' and 'mb', with the results being stored in the identically shaped <code>mc</code> matrix.  <a href="matrices_8c.html#a56496e3a46a6b598c50a5e086d07a1af">More...</a><br /></td></tr>
<tr class="separator:a56496e3a46a6b598c50a5e086d07a1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cc6c6a6070016da3d80756a27adf4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrices_8c.html#ac6cc6c6a6070016da3d80756a27adf4c">zsl_mtx_binary_func</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *ma, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mb, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mc, <a class="el" href="group___m_t_x___i_n_i_t.html#ga8ede693f977afd3b3b92c12ea98916e0">zsl_mtx_binary_fn_t</a> fn)</td></tr>
<tr class="memdesc:ac6cc6c6a6070016da3d80756a27adf4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a component-wise binary operztion on every coefficient in symmetrical matrices 'ma' and 'mb', with the results being stored in the identically shaped 'mc' matrix. The actual binary operation is executed using the specified 'zsl_mtx_binary_fn_t' callback.  <a href="matrices_8c.html#ac6cc6c6a6070016da3d80756a27adf4c">More...</a><br /></td></tr>
<tr class="separator:ac6cc6c6a6070016da3d80756a27adf4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadafa8d6fb79aae044fe9e91b53d25ca5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___b_a_s_i_c_m_a_t_h.html#gadafa8d6fb79aae044fe9e91b53d25ca5">zsl_mtx_add</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *ma, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mb, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mc)</td></tr>
<tr class="memdesc:gadafa8d6fb79aae044fe9e91b53d25ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds matrices 'ma' and 'mb', assigning the output to 'mc'. Matrices 'ma', 'mb' and 'mc' must all be identically shaped.  <a href="group___m_t_x___b_a_s_i_c_m_a_t_h.html#gadafa8d6fb79aae044fe9e91b53d25ca5">More...</a><br /></td></tr>
<tr class="separator:gadafa8d6fb79aae044fe9e91b53d25ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf7ba4fe899c8411ab76e5107ca75dd3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___b_a_s_i_c_m_a_t_h.html#gacf7ba4fe899c8411ab76e5107ca75dd3">zsl_mtx_add_d</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *ma, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mb)</td></tr>
<tr class="memdesc:gacf7ba4fe899c8411ab76e5107ca75dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds matrices 'ma' and 'mb', assigning the output to 'ma'. Matrices 'ma', and 'mb' must be identically shaped.  <a href="group___m_t_x___b_a_s_i_c_m_a_t_h.html#gacf7ba4fe899c8411ab76e5107ca75dd3">More...</a><br /></td></tr>
<tr class="separator:gacf7ba4fe899c8411ab76e5107ca75dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga436c94b399ffee81bde500e6525d348d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___b_a_s_i_c_m_a_t_h.html#ga436c94b399ffee81bde500e6525d348d">zsl_mtx_sum_rows_d</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, size_t i, size_t j)</td></tr>
<tr class="memdesc:ga436c94b399ffee81bde500e6525d348d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the values of row 'j' to row 'i' in matrix 'm'. This operation is destructive for row 'i'.  <a href="group___m_t_x___b_a_s_i_c_m_a_t_h.html#ga436c94b399ffee81bde500e6525d348d">More...</a><br /></td></tr>
<tr class="separator:ga436c94b399ffee81bde500e6525d348d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga172d38213cd5307d4ab10164944d23d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___b_a_s_i_c_m_a_t_h.html#ga172d38213cd5307d4ab10164944d23d2">zsl_mtx_sum_rows_scaled_d</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, size_t i, size_t j, <a class="el" href="zsl_8h.html#a057fbb03c8054ee788abfe8231ad8c81">zsl_real_t</a> s)</td></tr>
<tr class="memdesc:ga172d38213cd5307d4ab10164944d23d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the coefficients of row 'j' and multiplies them by scalar 's', then adds the resulting coefficient to the parallel element in row 'i'. Row 'i' will be modified in this operation.  <a href="group___m_t_x___b_a_s_i_c_m_a_t_h.html#ga172d38213cd5307d4ab10164944d23d2">More...</a><br /></td></tr>
<tr class="separator:ga172d38213cd5307d4ab10164944d23d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dde752601c7f860236c9b237ffbe2cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___b_a_s_i_c_m_a_t_h.html#ga8dde752601c7f860236c9b237ffbe2cc">zsl_mtx_sub</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *ma, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mb, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mc)</td></tr>
<tr class="memdesc:ga8dde752601c7f860236c9b237ffbe2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts matrices 'mb' from 'ma', assigning the output to 'mc'. Matrices 'ma', 'mb' and 'mc' must all be identically shaped.  <a href="group___m_t_x___b_a_s_i_c_m_a_t_h.html#ga8dde752601c7f860236c9b237ffbe2cc">More...</a><br /></td></tr>
<tr class="separator:ga8dde752601c7f860236c9b237ffbe2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace8795212fc299e361d6ae06a2910019"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___b_a_s_i_c_m_a_t_h.html#gace8795212fc299e361d6ae06a2910019">zsl_mtx_sub_d</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *ma, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mb)</td></tr>
<tr class="memdesc:gace8795212fc299e361d6ae06a2910019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts matrix 'mb' from 'ma', assigning the output to 'ma'. Matrices 'ma', and 'mb' must be identically shaped.  <a href="group___m_t_x___b_a_s_i_c_m_a_t_h.html#gace8795212fc299e361d6ae06a2910019">More...</a><br /></td></tr>
<tr class="separator:gace8795212fc299e361d6ae06a2910019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7af3587ae26b8d0f7f66dbc9da607ca4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___b_a_s_i_c_m_a_t_h.html#ga7af3587ae26b8d0f7f66dbc9da607ca4">zsl_mtx_mult</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *ma, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mb, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mc)</td></tr>
<tr class="memdesc:ga7af3587ae26b8d0f7f66dbc9da607ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies matrix 'ma' by 'mb', assigning the output to 'mc'. Matrices 'ma' and 'mb' must be compatibly shaped, meaning that 'ma' must have the same numbers of columns as there are rows in 'mb'.  <a href="group___m_t_x___b_a_s_i_c_m_a_t_h.html#ga7af3587ae26b8d0f7f66dbc9da607ca4">More...</a><br /></td></tr>
<tr class="separator:ga7af3587ae26b8d0f7f66dbc9da607ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6fce3ebdc306cc07bd2a54e6cab7934"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___b_a_s_i_c_m_a_t_h.html#gaa6fce3ebdc306cc07bd2a54e6cab7934">zsl_mtx_mult_d</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *ma, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mb)</td></tr>
<tr class="memdesc:gaa6fce3ebdc306cc07bd2a54e6cab7934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies matrix 'ma' by 'mb', assigning the output to 'ma'. Matrices 'ma' and 'mb' must be compatibly shaped, meaning that 'ma' must have the same numbers of columns as there are rows in 'mb'. To use this function, 'mb' must be a square matrix. This function is destructive.  <a href="group___m_t_x___b_a_s_i_c_m_a_t_h.html#gaa6fce3ebdc306cc07bd2a54e6cab7934">More...</a><br /></td></tr>
<tr class="separator:gaa6fce3ebdc306cc07bd2a54e6cab7934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaf34a793db55f062b6ca89d24fab939"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___b_a_s_i_c_m_a_t_h.html#gaaaf34a793db55f062b6ca89d24fab939">zsl_mtx_scalar_mult_d</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, <a class="el" href="zsl_8h.html#a057fbb03c8054ee788abfe8231ad8c81">zsl_real_t</a> s)</td></tr>
<tr class="memdesc:gaaaf34a793db55f062b6ca89d24fab939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies all elements in matrix 'm' by scalar value 's'.  <a href="group___m_t_x___b_a_s_i_c_m_a_t_h.html#gaaaf34a793db55f062b6ca89d24fab939">More...</a><br /></td></tr>
<tr class="separator:gaaaf34a793db55f062b6ca89d24fab939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf913e71cb6f2cb71df66a75d825b2594"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___b_a_s_i_c_m_a_t_h.html#gaf913e71cb6f2cb71df66a75d825b2594">zsl_mtx_scalar_mult_row_d</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, size_t i, <a class="el" href="zsl_8h.html#a057fbb03c8054ee788abfe8231ad8c81">zsl_real_t</a> s)</td></tr>
<tr class="memdesc:gaf913e71cb6f2cb71df66a75d825b2594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the elements of row 'i' in matrix 'm' by scalar 's'.  <a href="group___m_t_x___b_a_s_i_c_m_a_t_h.html#gaf913e71cb6f2cb71df66a75d825b2594">More...</a><br /></td></tr>
<tr class="separator:gaf913e71cb6f2cb71df66a75d825b2594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb736476f31c46e346958708006829e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga0eb736476f31c46e346958708006829e">zsl_mtx_trans</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *ma, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mb)</td></tr>
<tr class="memdesc:ga0eb736476f31c46e346958708006829e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes the matrix 'ma' into matrix 'mb'. Note that output matrix 'mb' must have 'ma-&gt;sz_rows' columns, and 'ma-&gt;sz_cols' rows.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga0eb736476f31c46e346958708006829e">More...</a><br /></td></tr>
<tr class="separator:ga0eb736476f31c46e346958708006829e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga969fb6872a3d2d5bad81467f1c82c7b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga969fb6872a3d2d5bad81467f1c82c7b5">zsl_mtx_adjoint_3x3</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *ma)</td></tr>
<tr class="memdesc:ga969fb6872a3d2d5bad81467f1c82c7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the ajoint matrix, based on the input 3x3 matrix 'm'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga969fb6872a3d2d5bad81467f1c82c7b5">More...</a><br /></td></tr>
<tr class="separator:ga969fb6872a3d2d5bad81467f1c82c7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c15f90b7cba1a35fdf9d2a83ca2bccb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga5c15f90b7cba1a35fdf9d2a83ca2bccb">zsl_mtx_adjoint</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *ma)</td></tr>
<tr class="memdesc:ga5c15f90b7cba1a35fdf9d2a83ca2bccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the ajoint matrix, based on the input square matrix 'm'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga5c15f90b7cba1a35fdf9d2a83ca2bccb">More...</a><br /></td></tr>
<tr class="separator:ga5c15f90b7cba1a35fdf9d2a83ca2bccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8acd7f91d2c7a29aaaf69170a4dfc568"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga8acd7f91d2c7a29aaaf69170a4dfc568">zsl_mtx_vec_wedge</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__vec.html">zsl_vec</a> *v)</td></tr>
<tr class="memdesc:ga8acd7f91d2c7a29aaaf69170a4dfc568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the wedge product of n-1 vectors of size n, which are the rows of the matrix 'm'. This n-1 vectors must be linearly independent.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga8acd7f91d2c7a29aaaf69170a4dfc568">More...</a><br /></td></tr>
<tr class="separator:ga8acd7f91d2c7a29aaaf69170a4dfc568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef303884e2ba3a6a9aa44d17033f0501"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaef303884e2ba3a6a9aa44d17033f0501">zsl_mtx_reduce</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mr, size_t i, size_t j)</td></tr>
<tr class="memdesc:gaef303884e2ba3a6a9aa44d17033f0501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes row 'i' and column 'j' from square matrix 'm', assigning the remaining elements in the matrix to 'mr'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaef303884e2ba3a6a9aa44d17033f0501">More...</a><br /></td></tr>
<tr class="separator:gaef303884e2ba3a6a9aa44d17033f0501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1a41d666f1657eaa86d8a4b3dfb67c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaa1a41d666f1657eaa86d8a4b3dfb67c0">zsl_mtx_reduce_iter</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mred)</td></tr>
<tr class="memdesc:gaa1a41d666f1657eaa86d8a4b3dfb67c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the number of rows/columns in the input square matrix 'm' to match the shape of 'mred', where mred &lt; m. Rows/cols will be removed starting on the left and upper vectors.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaa1a41d666f1657eaa86d8a4b3dfb67c0">More...</a><br /></td></tr>
<tr class="separator:gaa1a41d666f1657eaa86d8a4b3dfb67c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3463aef4a3593cc9e20edc859a83bc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaa3463aef4a3593cc9e20edc859a83bc6">zsl_mtx_augm_diag</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *maug)</td></tr>
<tr class="memdesc:gaa3463aef4a3593cc9e20edc859a83bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Augments the input square matrix with additional rows and columns, based on the size 'diff' between m and maug (where maug &gt; m). New rows and columns are assigned values based on an identity matrix, meaning 1.0 on the new diagonal values and 0.0 above and below the diagonal.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaa3463aef4a3593cc9e20edc859a83bc6">More...</a><br /></td></tr>
<tr class="separator:gaa3463aef4a3593cc9e20edc859a83bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7531eca1242868f4476e97b6b1c836df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga7531eca1242868f4476e97b6b1c836df">zsl_mtx_deter_3x3</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, <a class="el" href="zsl_8h.html#a057fbb03c8054ee788abfe8231ad8c81">zsl_real_t</a> *d)</td></tr>
<tr class="memdesc:ga7531eca1242868f4476e97b6b1c836df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the determinant of the input 3x3 matrix 'm'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga7531eca1242868f4476e97b6b1c836df">More...</a><br /></td></tr>
<tr class="separator:ga7531eca1242868f4476e97b6b1c836df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a6f65ffda35bed1f042bb8d7603e572"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga5a6f65ffda35bed1f042bb8d7603e572">zsl_mtx_deter</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, <a class="el" href="zsl_8h.html#a057fbb03c8054ee788abfe8231ad8c81">zsl_real_t</a> *d)</td></tr>
<tr class="memdesc:ga5a6f65ffda35bed1f042bb8d7603e572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the determinant of the input square matrix 'm'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga5a6f65ffda35bed1f042bb8d7603e572">More...</a><br /></td></tr>
<tr class="separator:ga5a6f65ffda35bed1f042bb8d7603e572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a1ff09dc06d65d016b2153bb77baa14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga0a1ff09dc06d65d016b2153bb77baa14">zsl_mtx_gauss_elim</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mg, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mi, size_t i, size_t j)</td></tr>
<tr class="memdesc:ga0a1ff09dc06d65d016b2153bb77baa14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the element (i,j) in matrix 'm', this function performs gaussian elimination by adding row 'i' to the other rows until all of the elements in column 'j' are equal to 0.0, aside from the element at position (i, j). The result of this process will be assigned to matrix 'mg'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga0a1ff09dc06d65d016b2153bb77baa14">More...</a><br /></td></tr>
<tr class="separator:ga0a1ff09dc06d65d016b2153bb77baa14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4cc183aea8b54e3a7c9b15f7d855637"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaf4cc183aea8b54e3a7c9b15f7d855637">zsl_mtx_gauss_elim_d</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mi, size_t i, size_t j)</td></tr>
<tr class="memdesc:gaf4cc183aea8b54e3a7c9b15f7d855637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the element (i,j) in matrix 'm', this function performs gaussian elimination by adding row 'i' to the other rows until all of the elements in column 'j' are equal to 0.0, aside from the element at position (i, j). This function is destructive and will modify the contents of m.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaf4cc183aea8b54e3a7c9b15f7d855637">More...</a><br /></td></tr>
<tr class="separator:gaf4cc183aea8b54e3a7c9b15f7d855637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75b64b8d5fa54b8df6731c64a20109dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga75b64b8d5fa54b8df6731c64a20109dd">zsl_mtx_gauss_reduc</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mi, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mg)</td></tr>
<tr class="memdesc:ga75b64b8d5fa54b8df6731c64a20109dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given matrix 'm', puts the matrix into echelon form using Gauss-Jordan reduction.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga75b64b8d5fa54b8df6731c64a20109dd">More...</a><br /></td></tr>
<tr class="separator:ga75b64b8d5fa54b8df6731c64a20109dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33556c879cbd3afe108506041e21a761"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga33556c879cbd3afe108506041e21a761">zsl_mtx_gram_schmidt</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mort)</td></tr>
<tr class="memdesc:ga33556c879cbd3afe108506041e21a761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Gram-Schmidt algorithm on the set of column vectors in matrix 'm'. This algorithm calculates a set of orthogonal vectors in the same vectorial space as the original vectors.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga33556c879cbd3afe108506041e21a761">More...</a><br /></td></tr>
<tr class="separator:ga33556c879cbd3afe108506041e21a761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga756944b115550c5798f4270b641cd1bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga756944b115550c5798f4270b641cd1bb">zsl_mtx_cols_norm</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mnorm)</td></tr>
<tr class="memdesc:ga756944b115550c5798f4270b641cd1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the values of every column vector in input matrix 'm' to have unitary values.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga756944b115550c5798f4270b641cd1bb">More...</a><br /></td></tr>
<tr class="separator:ga756944b115550c5798f4270b641cd1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf5e94e0ebfd5599d84b4eba90430c54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gabf5e94e0ebfd5599d84b4eba90430c54">zsl_mtx_norm_elem</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mn, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mi, size_t i, size_t j)</td></tr>
<tr class="memdesc:gabf5e94e0ebfd5599d84b4eba90430c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalises elements in matrix m such that the element at position (i, j) is equal to 1.0.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gabf5e94e0ebfd5599d84b4eba90430c54">More...</a><br /></td></tr>
<tr class="separator:gabf5e94e0ebfd5599d84b4eba90430c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ead751c3d4ce5a5081836febd21b6d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga7ead751c3d4ce5a5081836febd21b6d5">zsl_mtx_norm_elem_d</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mi, size_t i, size_t j)</td></tr>
<tr class="memdesc:ga7ead751c3d4ce5a5081836febd21b6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalises elements in matrix m such that the element at position (i, j) is equal to 1.0. This function is destructive and will modify the contents of m.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga7ead751c3d4ce5a5081836febd21b6d5">More...</a><br /></td></tr>
<tr class="separator:ga7ead751c3d4ce5a5081836febd21b6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa96f965d0fb43be0fc08b957ac4ca85d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaa96f965d0fb43be0fc08b957ac4ca85d">zsl_mtx_inv_3x3</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mi)</td></tr>
<tr class="memdesc:gaa96f965d0fb43be0fc08b957ac4ca85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse of 3x3 matrix 'm'. If the determinant of 'm' is zero, an identity matrix will be returned via 'mi'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaa96f965d0fb43be0fc08b957ac4ca85d">More...</a><br /></td></tr>
<tr class="separator:gaa96f965d0fb43be0fc08b957ac4ca85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6268baeb64622466c50c6950f89a8392"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga6268baeb64622466c50c6950f89a8392">zsl_mtx_inv</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mi)</td></tr>
<tr class="memdesc:ga6268baeb64622466c50c6950f89a8392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse of square matrix 'm'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga6268baeb64622466c50c6950f89a8392">More...</a><br /></td></tr>
<tr class="separator:ga6268baeb64622466c50c6950f89a8392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9742df56d688a36fe9ede6796638fb5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga9742df56d688a36fe9ede6796638fb5c">zsl_mtx_cholesky</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *l)</td></tr>
<tr class="memdesc:ga9742df56d688a36fe9ede6796638fb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Cholesky decomposition of a symmetric square matrix using the Cholesky–Crout algorithm.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga9742df56d688a36fe9ede6796638fb5c">More...</a><br /></td></tr>
<tr class="separator:ga9742df56d688a36fe9ede6796638fb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f6237b030695a1e3c6603eecd47448c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga1f6237b030695a1e3c6603eecd47448c">zsl_mtx_balance</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mout)</td></tr>
<tr class="memdesc:ga1f6237b030695a1e3c6603eecd47448c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balances the square matrix 'm', a process in which the eigenvalues of the output matrix are the same as the eigenvalues of the input matrix.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga1f6237b030695a1e3c6603eecd47448c">More...</a><br /></td></tr>
<tr class="separator:ga1f6237b030695a1e3c6603eecd47448c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa8cbce5a3094d2292f1e4ec3402b470"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gafa8cbce5a3094d2292f1e4ec3402b470">zsl_mtx_householder</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *h, bool hessenberg)</td></tr>
<tr class="memdesc:gafa8cbce5a3094d2292f1e4ec3402b470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the householder reflection of 'm'. Used as part of QR decomposition. When 'hessenberg' is active, it calculates the householder reflection but without using the first line of 'm'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gafa8cbce5a3094d2292f1e4ec3402b470">More...</a><br /></td></tr>
<tr class="separator:gafa8cbce5a3094d2292f1e4ec3402b470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b76643a6acf826c442cfa24e5fe83d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaf9b76643a6acf826c442cfa24e5fe83d">zsl_mtx_qrd</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *q, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *r, bool hessenberg)</td></tr>
<tr class="memdesc:gaf9b76643a6acf826c442cfa24e5fe83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If 'hessenberg' is set to false, this function performs the QR decomposition, which is a factorisation of matrix 'm' into an orthogonal matrix (q) and an upper triangular matrix (r). If 'hessenberg' is set to true, this function puts the matrix 'm' into hessenberg form. This function uses the householder reflections.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaf9b76643a6acf826c442cfa24e5fe83d">More...</a><br /></td></tr>
<tr class="separator:gaf9b76643a6acf826c442cfa24e5fe83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1156b53e640a1dbab183a18eac2db93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaa1156b53e640a1dbab183a18eac2db93">zsl_mtx_qrd_iter</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mout, size_t iter)</td></tr>
<tr class="memdesc:gaa1156b53e640a1dbab183a18eac2db93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes recursively the QR decompisition method to put the input square matrix into upper triangular form.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaa1156b53e640a1dbab183a18eac2db93">More...</a><br /></td></tr>
<tr class="separator:gaa1156b53e640a1dbab183a18eac2db93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0289da37e5c6f926a7513ac13fa2b158"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga0289da37e5c6f926a7513ac13fa2b158">zsl_mtx_eigenvalues</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__vec.html">zsl_vec</a> *v, size_t iter)</td></tr>
<tr class="memdesc:ga0289da37e5c6f926a7513ac13fa2b158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the eigenvalues for input matrix 'm' using QR decomposition recursively. The output vector will only contain real eigenvalues, even if the input matrix has complex eigenvalues.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga0289da37e5c6f926a7513ac13fa2b158">More...</a><br /></td></tr>
<tr class="separator:ga0289da37e5c6f926a7513ac13fa2b158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0176385192f0884c6ec58d81d8a0a78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaa0176385192f0884c6ec58d81d8a0a78">zsl_mtx_eigenvectors</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mev, size_t iter, bool orthonormal)</td></tr>
<tr class="memdesc:gaa0176385192f0884c6ec58d81d8a0a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcualtes the set of eigenvectors for input matrix 'm', using the specified number of iterations to find a balance between precision and processing effort. Optionally, the output eigenvectors can be orthonormalised.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gaa0176385192f0884c6ec58d81d8a0a78">More...</a><br /></td></tr>
<tr class="separator:gaa0176385192f0884c6ec58d81d8a0a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga443cf9708594a814e8bc6a2fb5c60612"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga443cf9708594a814e8bc6a2fb5c60612">zsl_mtx_svd</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *u, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *e, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *v, size_t iter)</td></tr>
<tr class="memdesc:ga443cf9708594a814e8bc6a2fb5c60612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs singular value decomposition, converting input matrix 'm' into matrices 'u', 'e', and 'v'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#ga443cf9708594a814e8bc6a2fb5c60612">More...</a><br /></td></tr>
<tr class="separator:ga443cf9708594a814e8bc6a2fb5c60612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab54e0c3ffbd2b626284628688316293a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gab54e0c3ffbd2b626284628688316293a">zsl_mtx_pinv</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *pinv, size_t iter)</td></tr>
<tr class="memdesc:gab54e0c3ffbd2b626284628688316293a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the pseudo-inverse (aka pinv or Moore-Penrose inverse) on input matrix 'm'.  <a href="group___m_t_x___t_r_a_n_s_f_o_r_m_a_t_i_o_n_s.html#gab54e0c3ffbd2b626284628688316293a">More...</a><br /></td></tr>
<tr class="separator:gab54e0c3ffbd2b626284628688316293a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e2807a7365eefe047e0b16f139e6b67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___l_i_m_i_t_s.html#ga0e2807a7365eefe047e0b16f139e6b67">zsl_mtx_min</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, <a class="el" href="zsl_8h.html#a057fbb03c8054ee788abfe8231ad8c81">zsl_real_t</a> *x)</td></tr>
<tr class="memdesc:ga0e2807a7365eefe047e0b16f139e6b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverses the matrix elements to find the minimum element value.  <a href="group___m_t_x___l_i_m_i_t_s.html#ga0e2807a7365eefe047e0b16f139e6b67">More...</a><br /></td></tr>
<tr class="separator:ga0e2807a7365eefe047e0b16f139e6b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb3b34a0d125375dd2f3d163aab75a95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___l_i_m_i_t_s.html#gafb3b34a0d125375dd2f3d163aab75a95">zsl_mtx_max</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, <a class="el" href="zsl_8h.html#a057fbb03c8054ee788abfe8231ad8c81">zsl_real_t</a> *x)</td></tr>
<tr class="memdesc:gafb3b34a0d125375dd2f3d163aab75a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverses the matrix elements to find the maximum element value.  <a href="group___m_t_x___l_i_m_i_t_s.html#gafb3b34a0d125375dd2f3d163aab75a95">More...</a><br /></td></tr>
<tr class="separator:gafb3b34a0d125375dd2f3d163aab75a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f24004757a64ecf7a2c573a286dc7d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___l_i_m_i_t_s.html#ga4f24004757a64ecf7a2c573a286dc7d4">zsl_mtx_min_idx</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, size_t *i, size_t *j)</td></tr>
<tr class="memdesc:ga4f24004757a64ecf7a2c573a286dc7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverses the matrix elements to find the (i,j) index of the minimum element value. If multiple identical minimum values are founds, the (i, j) index values returned will refer to the first element.  <a href="group___m_t_x___l_i_m_i_t_s.html#ga4f24004757a64ecf7a2c573a286dc7d4">More...</a><br /></td></tr>
<tr class="separator:ga4f24004757a64ecf7a2c573a286dc7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9e25efd22f8eb587d851f5bd2759e66"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___l_i_m_i_t_s.html#gad9e25efd22f8eb587d851f5bd2759e66">zsl_mtx_max_idx</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m, size_t *i, size_t *j)</td></tr>
<tr class="memdesc:gad9e25efd22f8eb587d851f5bd2759e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverses the matrix elements to find the (i,j) index of the maximum element value. If multiple identical maximum values are founds, the (i, j) index values returned will refer to the first element.  <a href="group___m_t_x___l_i_m_i_t_s.html#gad9e25efd22f8eb587d851f5bd2759e66">More...</a><br /></td></tr>
<tr class="separator:gad9e25efd22f8eb587d851f5bd2759e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f8c743f0d3b7d0efdcbc16145a1f92b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___c_o_m_p_a_r_i_s_o_n.html#ga9f8c743f0d3b7d0efdcbc16145a1f92b">zsl_mtx_is_equal</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *ma, struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *mb)</td></tr>
<tr class="memdesc:ga9f8c743f0d3b7d0efdcbc16145a1f92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two matrices are identical in shape and content.  <a href="group___m_t_x___c_o_m_p_a_r_i_s_o_n.html#ga9f8c743f0d3b7d0efdcbc16145a1f92b">More...</a><br /></td></tr>
<tr class="separator:ga9f8c743f0d3b7d0efdcbc16145a1f92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f281b6490db543966ec38b03195f130"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___c_o_m_p_a_r_i_s_o_n.html#ga1f281b6490db543966ec38b03195f130">zsl_mtx_is_notneg</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m)</td></tr>
<tr class="memdesc:ga1f281b6490db543966ec38b03195f130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all elements in matrix m are &gt;= zero.  <a href="group___m_t_x___c_o_m_p_a_r_i_s_o_n.html#ga1f281b6490db543966ec38b03195f130">More...</a><br /></td></tr>
<tr class="separator:ga1f281b6490db543966ec38b03195f130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga816edeec71dd9ecf8edeb6622962e81d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___c_o_m_p_a_r_i_s_o_n.html#ga816edeec71dd9ecf8edeb6622962e81d">zsl_mtx_is_sym</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m)</td></tr>
<tr class="memdesc:ga816edeec71dd9ecf8edeb6622962e81d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the square input matrix is symmetric.  <a href="group___m_t_x___c_o_m_p_a_r_i_s_o_n.html#ga816edeec71dd9ecf8edeb6622962e81d">More...</a><br /></td></tr>
<tr class="separator:ga816edeec71dd9ecf8edeb6622962e81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a4fce4aa2e3cc49df02217475dc9241"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_t_x___d_i_s_p_l_a_y.html#ga2a4fce4aa2e3cc49df02217475dc9241">zsl_mtx_print</a> (struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *m)</td></tr>
<tr class="memdesc:ga2a4fce4aa2e3cc49df02217475dc9241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Printf the supplied matrix using printf in a human-readable manner.  <a href="group___m_t_x___d_i_s_p_l_a_y.html#ga2a4fce4aa2e3cc49df02217475dc9241">More...</a><br /></td></tr>
<tr class="separator:ga2a4fce4aa2e3cc49df02217475dc9241"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac6cc6c6a6070016da3d80756a27adf4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6cc6c6a6070016da3d80756a27adf4c">&#9670;&nbsp;</a></span>zsl_mtx_binary_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_binary_func </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>ma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_t_x___i_n_i_t.html#ga8ede693f977afd3b3b92c12ea98916e0">zsl_mtx_binary_fn_t</a>&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a component-wise binary operztion on every coefficient in symmetrical matrices 'ma' and 'mb', with the results being stored in the identically shaped 'mc' matrix. The actual binary operation is executed using the specified 'zsl_mtx_binary_fn_t' callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ma</td><td>Pointer to first <a class="el" href="structzsl__mtx.html" title="Represents a m x n matrix, with data stored in row-major order.">zsl_mtx</a> to use in the binary operation. </td></tr>
    <tr><td class="paramname">mb</td><td>Pointer to second <a class="el" href="structzsl__mtx.html" title="Represents a m x n matrix, with data stored in row-major order.">zsl_mtx</a> to use in the binary operation. </td></tr>
    <tr><td class="paramname">mc</td><td>Pointer to output <a class="el" href="structzsl__mtx.html" title="Represents a m x n matrix, with data stored in row-major order.">zsl_mtx</a> used to store results. </td></tr>
    <tr><td class="paramname">fn</td><td>The zsl_mtx_binary_fn_t instance to call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, and non-zero error code on failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l00347">347</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

</div>
</div>
<a id="a56496e3a46a6b598c50a5e086d07a1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56496e3a46a6b598c50a5e086d07a1af">&#9670;&nbsp;</a></span>zsl_mtx_binary_op()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group___m_t_x___o_p_e_r_a_n_d_s.html#gae4d5efed267c13a5810a2a3df6f4ee4c">zsl_mtx_binary_op</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>ma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>mc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_t_x___o_p_e_r_a_n_d_s.html#gac0cbe53e633a7f5536ce38079acc0ec1">zsl_mtx_binary_op_t</a>&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a component-wise binary operation on every coefficient in symmetrical matrices 'ma' and 'mb', with the results being stored in the identically shaped <code>mc</code> matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ma</td><td>Pointer to first <a class="el" href="structzsl__mtx.html" title="Represents a m x n matrix, with data stored in row-major order.">zsl_mtx</a> to use in the binary operation. </td></tr>
    <tr><td class="paramname">mb</td><td>Pointer to second <a class="el" href="structzsl__mtx.html" title="Represents a m x n matrix, with data stored in row-major order.">zsl_mtx</a> to use in the binary operation. </td></tr>
    <tr><td class="paramname">mc</td><td>Pointer to output <a class="el" href="structzsl__mtx.html" title="Represents a m x n matrix, with data stored in row-major order.">zsl_mtx</a> used to store results. </td></tr>
    <tr><td class="paramname">op</td><td>The binary operation to apply to each coefficient.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, and non-zero error code on failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l00286">286</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="matrices_8c_source.html#l00375">zsl_mtx_add()</a>, <a class="el" href="matrices_8c_source.html#l00381">zsl_mtx_add_d()</a>, <a class="el" href="matrices_8c_source.html#l00422">zsl_mtx_sub()</a>, and <a class="el" href="matrices_8c_source.html#l00428">zsl_mtx_sub_d()</a>.</p>

</div>
</div>
<a id="acd80909db4e363cf6dbf950811414f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd80909db4e363cf6dbf950811414f6a">&#9670;&nbsp;</a></span>zsl_mtx_unary_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zsl_mtx_unary_func </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structzsl__mtx.html">zsl_mtx</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___m_t_x___i_n_i_t.html#ga93ed6864f0c3adafcd4327cd88d96c0a">zsl_mtx_unary_fn_t</a>&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a unary function on every coefficient in matrix 'm', using the specified 'zsl_mtx_apply_unary_fn_t' instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Pointer to the <a class="el" href="structzsl__mtx.html" title="Represents a m x n matrix, with data stored in row-major order.">zsl_mtx</a> to use. </td></tr>
    <tr><td class="paramname">fn</td><td>The zsl_mtx_unary_fn_t instance to call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, and non-zero error code on failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrices_8c_source.html#l00266">266</a> of file <a class="el" href="matrices_8c_source.html">matrices.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
