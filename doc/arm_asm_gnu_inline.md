# Inline ARM Assembly with GNU

To ensure optimal performance when running on ARM Thumb or ARM Thumb-2
devices, zscilib includes support for re-implementing key functions in
inline assembly.

This high-level overview describes some of the details of using inline
assembly with ARM and the GNU toolchain. It isn't intended as a primer on
ARM Thumb assembly, but rather an aid to understanding the optimized functions
in zscilib, and to assist contributors in adding properly formatted
optimisations.

## GNU Inline Assembly Format

When connecting inline assembly and C using GNU, the assembly code generally
takes the following form:

```
__asm__ volatile (
    code
    : output operand list
    : input operand list
    : clobber list
);
```

### code

This mandatory section includes the assembler instructions as string literals.

- Each line of assembly should be **enclosed in double-quotes**, and terminated
  with the **`\n\t`** sequence, which ensures proper formatting of the assembly
  code generated by the compiler.

### output operand list

The second section in the inline assembly is the **output operand list**, which
allows the C and inline assembly code to share **output** operands.

- Multiple output operands should be **comma separated**.
- The **symbolic name** of the operand should be enclosed in square brackets
  `[]`, followed by the **constraint string** enclosed in double quotes `""`,
  followed by the **C expression** enclosed in parentheses `()`.

> For a list of possible **constraint string** values, see ARM Thumb Constraint
Modifiers/Codes further below.

For example, the output operand list:

```
    : [dptr] "+l" (result)
```

- Declares the asm symbolic name `dptr` (accessible as `%[dptr]` in asm code).
- Adds a readwrite constraint (`+l`) with use of Thumb state core registers
  **R0-R7**.
- Associates it with the `result` C expression.


### input operand list

The third section in the inline assembly is the **input operand list**, which
allows the C and inline assembly code to share **input** operands.

This uses the same syntax as the list of output operands.

For example, the input operand list:

```
    : [value] "l" (x)
```

- Declares the asm symbolic name `value` (accessible as `%[value]` in the asm
  code).
- Indicates that the thumb state general purpose registers should be used
- Associates it with the `x` C expression.


### clobber list

The fourth and final section in the inline assembly is the **clobber list**,
which informs the compiler which values are changed by the assembly code.

In the comma-separated clobber list, You can include:

- Specific core or VFP registers (`"r12"`)
- The **condition register** (`"cc"`)
- The `"memory"` keyword to tell the compiler that the assembler instructions
  may change memory locations, forcing the compiler to store all cached values
  before and reload them after executing the assembler instructions.

For example, the following clobber list entry indicates that we change the
condition register, and that we likely alter memory locations:

```
    : "cc", "memory"
```

## ARM Thumb Constraint Modifiers/Codes

Constraint modifiers and codes are used to control which registers are used
when compiling asm code for the ARM core, and the type of access they have.

An exhaustive list of ARM constraints for GNU is
available in the GCC documentation: [Constraints for Particular Machines](https://gcc.gnu.org/onlinedocs/gcc/Machine-Constraints.html#Machine-Constraints)

### Constraint modifiers

Possible ARM Thumb constraint modifiers are:

- `+` **readwrite**: This operand is both read from and written to.
- `=` **write**: This operand is only written to, and only after all input
  operands have been read for the last time. Output only.
- `=&` **write**: This operand is only written to. It might be modified
  before the assembly block finishes reading the input operands. Therefore the
  compiler cannot use the same register to store this operand and an input
  operand. Operands with the `=&` constraint modifier are known as
  early-clobber operands. Output only.

> Use the `&` constraint modifier on all output operands that must not overlap
  an input. Otherwise, GCC may allocate the output operand in the same register
  as an unrelated input operand, on the assumption that the assembler code
  consumes its inputs before producing outputs. This assumption may be false
  if the assembler code actually consists of more than one instruction.

### Constraint codes

Possible ARM Thumb constraint codes are:

- `l` : Thumb state general purpose registers
  - Operand must be an integer or floating-point type.
  - For T32 state, the compiler can use **R0-R7**.
  - For A32 state, the compiler can use **R0-R12**, or **R14**.
- `h` : Thumb state upper general purpose registers
  - Operand must be an integer or floating-point type.
  - For T32 state, the compiler can use **R8-R12**, or **R14**.
  - Not valid for A32 state!
- `t` : Vector floating point registers
  - Operand must be a 32-bit floating-point or integer type.
  - The compiler can use **S0-S31**.
- `w` : Vector floating point registers
  - Operand must be a 64-bit floating-point or vector type, or a 64-bit integer.
  - The compiler can use **S0-S31**, **D0-D31**, or **Q0-Q15**, depending on
    the size of the operand type.
  - Not valid for Thumb1.

## Register Usage

TODO: Add link to ARM document on function argument usage in assembly.

The table below lists core registers for ARM devices and their usage:

| Register   | Usage |
|------------|-------|
| R0         | First function argument, Integer function result, Scratch reg. |
| R1         | Second function argument, Scratch reg. |
| R2         | Third function argument, Scratch reg. |
| R3         | Fourth function argument, Scratch reg. |
| R4         | Register variable |
| R5         | Register variable |
| R6         | Register variable |
| R7         | Register variable |
| R8         | Register variable |
| R9 (`rfp`) | Register variable, Real frame pointer |
| R10 (`sl`) | Stack limit |
| R11 (`fp`) | Argument pointer |
| R12 (`lp`) | Temporary workspace |
| R13 (`sp`) | Stack pointer |
| R14 (`lr`) | Link register, Workspace |
| R15 (`pc`) | Program counter |

## Sources and Further Reading

- [ARM inline assembly](http://www.ethernut.de/en/documents/arm-inline-asm.html)
  Somewhat dated, but very useful summary of GNU inline ARM assembly.
- [GNU Extended ASM](https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Extended-Asm)
  Details the format used for inline assembler instructions with C expression
  operands
